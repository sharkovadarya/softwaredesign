package ru.hse.spb.sd.sharkova.interpreter

import java.util.regex.Pattern


class CLIParser : Parser {
    private val keywords = listOf("cat", "echo", "wc", "pwd", "exit")
    private val identifierRegex = Regex("[_a-z][_a-z0-9]*")
    private val substitutionRegex = Regex("^\\$$identifierRegex")
    private val identifierAssignmentPattern = Pattern.compile("^$identifierRegex=")

    private val assignedVariables = HashMap<String, String>()
    private val errorList = mutableListOf<String>()

    private val interpreter = Interpreter()


    /**
     * This method accepts a line of input, breaks it into pipe-joined commands
     * and executes each command.
     * @param input a string from command line containing commands to be executed
     * @return list of strings generated by last executed command
     */
    override fun parseInput(input: String): List<String> {
        val commands = input.split(Regex("[ ]*\\|[ ]*")).filter { it.isNotEmpty() }

        var pos = 0
        var list: List<String> = emptyList()
        while (pos < commands.size) {
            val command = commands[pos]
            val str = extractQuotesFromCommand(command)
            // if it was in quotes then it should be interpreted as a whole command
            val executeAsExternalCommand = str != command

            val words = splitStringIntoWords(str)

            var nextPosition = if (!executeAsExternalCommand) extractVariableAssignments(words) else 0
            if (nextPosition >= words.size) {
                pos++
                continue
            }
            val word = words[nextPosition++]

            val arguments = mutableListOf<String>()
            while (nextPosition < words.size) {
                var arg = words[nextPosition++]
                // if there are any quotes, all substitutions are performed inside quotes extraction
                if (substitutionRegex.matches(arg)) {
                    val variableName = arg.drop(1)
                    arg = assignedVariables[variableName] ?: ""
                }
                arg = extractQuotesFromArgument(arg)
                if (!checkQuotesAbsence(arg)) {
                    throw MismatchedQuotesException()
                }
                arguments.add(arg)
            }

            if (executeAsExternalCommand) {
                processExternalCommand(word, arguments)
                pos++
                continue
            }

            list = parseCommand(word, arguments, list)
            pos++
        }


        val result = mutableListOf<String>()
        result.addAll(list)
        result.addAll(errorList)
        return result
    }


    private fun substituteInString(string: String): String {
        return string.replace(substitutionRegex) { getSubstitution(it.value)}
    }

    private fun extractQuotesFromCommand(string: String): String {
        var str = string.trim()
        if (str.first() != '\"' && str.first() != '\'') {
            return str
        }
        if (str.first() == '\"' && str.last() == '\"') {
            str = substituteInString(str)
        }
        var i = 0
        var j = str.lastIndex
        while (i <= j) {
            while (str[i] == '\"' && str[j] == '\"') {
                i++
                j--
            }
            while (str[i] == '\'' && str[j] == '\"') {
                i++
                j--
            }
            if (!(str[i] == '\"' && str[j] == '\"' || str[i] == '\'' && str[j] == '\'')) {
                break
            }
        }
        return str.substring(IntRange(i, j))
    }

    private fun extractQuotesFromArgument(string: String): String {
        var str = string.trim()
        var shouldPerformSubstitution = true

        fun extractQuotes(string: String, quote: Char): Triple<String, String, String>? {
            var i = string.indexOf(quote)
            var j = string.lastIndexOf(quote)
            if (i != -1 && j != -1) {
                if (i == j) {
                    throw MismatchedQuotesException()
                }
                val precedingCharacters = string.substring(0, i)
                val proceedingCharacters = string.substring(j + 1, string.length)
                while (string[i] == quote && string[j] == quote && i < j) {
                    i++
                    j--
                }
                return Triple(precedingCharacters, string.substring(IntRange(i, j)), proceedingCharacters)
            }

            return null
        }

        while (true) {
            val extractedSingleQuotesString = extractQuotes(str, '\'')
            if (extractedSingleQuotesString != null) {
                str = extractedSingleQuotesString.first +
                        extractedSingleQuotesString.second +
                        extractedSingleQuotesString.third
            } else {
                val extractedDoubleQuotesString = extractQuotes(str, '\"')
                if (extractedDoubleQuotesString != null) {
                    val substr = if (shouldPerformSubstitution) {
                        substituteInString(extractedDoubleQuotesString.second)
                    } else {
                        extractedDoubleQuotesString.second
                    }
                    str = extractedDoubleQuotesString.first + substr + extractedDoubleQuotesString.third
                    shouldPerformSubstitution = false
                } else {
                    break
                }
            }
        }

        return str
    }

    private fun getSubstitution(variable: String): String = assignedVariables[variable.drop(1)] ?: ""

    private fun extractVariableAssignments(words: List<String>): Int {
        var nextCommandPosition = 0
        var i = 0
        while (i < words.size) {
            val identifierAssignmentMatcher = identifierAssignmentPattern.matcher(words[i])
            if (identifierAssignmentMatcher.find()) {
                val variableName = identifierAssignmentMatcher.group().dropLast(1) // delete the '='
                var assignedValue = words[i].substring(variableName.length + 1)
                if (assignedValue.isEmpty()) {
                    i++
                    if (i < words.size && (words[i].first() == '\"' || words[i].first() == '\'')) {
                        assignedValue = words[i]
                    }
                }

                var variableValue = extractQuotesFromArgument(assignedValue)
                if (substitutionRegex.matches(variableValue)) {
                    variableValue = getSubstitution(variableValue)
                }
                assignedVariables[variableName] = variableValue

                nextCommandPosition = i + 1
            } else {
                nextCommandPosition = i
                break
            }

            i++
        }

        return nextCommandPosition
    }

    private fun processKeyword(word: String,
                               arguments: List<String>,
                               previousResult: List<String>): List<String> {
        return try {
            when (word) {
                "cat" -> { interpreter.executeCat(arguments) }
                "echo" -> { interpreter.executeEcho(arguments) }
                "wc" -> {
                    if (arguments.isEmpty() && previousResult.isEmpty()) {
                        listOf("wc: No arguments provided")
                    } else {
                        if (arguments.isNotEmpty()) {
                            interpreter.executeFileWc(arguments)
                        } else {
                            interpreter.executePipeWc(previousResult)
                        }
                    }
                }
                "pwd" -> { interpreter.executePwd() }
                "exit" -> { interpreter.executeExit() }
                else -> {emptyList()}
            }
        } catch (e: InterpreterException) {
            val errorMessage = e.message
            if (errorMessage != null) {
                errorList.add(errorMessage)
            }
            emptyList()
        }
    }

    private fun processExternalCommand(commandName: String, arguments: List<String>) {
        val externalCommand = mutableListOf(commandName)
        externalCommand.addAll(arguments)
        interpreter.executeExternalCommand(externalCommand)
    }

    private fun parseCommand(word: String, arguments: List<String>, previousResult: List<String>): List<String> {
        var res = listOf<String>()

        if (!keywords.contains(word)) {
            if (substitutionRegex.matches(word)) {
                val substitution = getSubstitution(word)
                res = parseCommand(substitution, emptyList(), previousResult)
            } else {
                processExternalCommand(word, arguments)
            }
        } else {
            res = processKeyword(word, arguments, previousResult)
        }

        return res
    }

    private fun splitStringIntoWords(str: String): List<String> {
        val wordsWithQuotes = str.splitByPattern("""["']+[^"']+?["']+""")
        if (wordsWithQuotes.isEmpty()) {
            return str.split(" ")
        }
        val lastPartWithoutQuotes = str.lastIndexOf(wordsWithQuotes.last()) + wordsWithQuotes.last().length
        val words = mutableListOf<String>()
        wordsWithQuotes.forEach { if (it[0] == '\"' || it[0] == '\'') {
            words.add(it)
        } else {
            words.addAll(it.split(" "))
        } }
        if (lastPartWithoutQuotes < str.length) {
            words.add(str.substring(lastPartWithoutQuotes))
        }
        return words.filter { it.isNotEmpty() }
    }

    private fun checkQuotesAbsence(string: String): Boolean {
        return !(string.contains("\"") || string.contains("\'"))
    }

    // method taken from https://stackoverflow.com/a/54525271/7735110
    private fun String.splitByPattern(pattern: String): List<String> {
        val indices = Regex(pattern).findAll(this)
                .map{ listOf(it.range.start, it.range.endInclusive) }.flatten().toMutableList()

        var lastIndex = 0
        return indices.mapIndexed { i, ele ->

            val end = if(i % 2 == 0) ele else ele + 1

            substring(lastIndex, end).apply {
                lastIndex = end
            }
        }
    }
}