# Интерпретатор командной строки


## Доступные команды


 * `echo` --- выводит свои аргументы, разделяя их одним пробелом и дописывая в конец символ перевода строки.

 * `cat [FILE]` --- выводит содержимое файла

 * `wc` --- выводит количество строк, слов и байт в переданном вводе (файл / вывод предыдущей команды, передаваемый через pipe)

 * `pwd` --- выводит текущую директорию

 * `exit` --- завершает работу интепретатора

 * `identifier=value` --- присвоение значения переменной

 * `command1 | command2` --- выполнение `command2` после `command1` с передачей вывода `command1` в `command2`

 * `$identifier` --- подстановка присвоенного переменной значения

 * одинарные и двойные кавычки

 * Остальные команды интепретируются и выполняются как внешние.


## Классы

 * `Parser` разбирает переданную ему строку ввода на команды и обращается к интепретатору для выполнения каждой команды.

 * `Interpreter` выполняет доступные команды (`echo` и т.д.).

 * `ParserException` --- исключение, брошенное при работе парсера (например, `MismatchedQuotesException` --- непарные кавычки).


## Архитектура

Доступна по [ссылке](https://drive.google.com/file/d/1qlaVGDnPs9YbyhTWftAQVogwZhpB_L91/view?usp=sharing "draw.io").

## Разбор аргументов командной строки

Для разбора аргументов командной строки используется библиотека [JCommander](http://jcommander.org/ "JCommander").

#### Причины использования: 

 * простой, легко понятный интерфейс 

 * в хорошо написанной документации представлено много примеров, поэтому несложно быстро разобраться с тем, как использовать библиотеку

 * без излишеств


#### Другие рассмотренные библиотеки:

 * **picocli**: поощряет пользователей подключать библиотеку не как дополнительную зависимость, а вставлять одним файлом-исходником; мне не нравится такой подход

 * **commons-cli**: интерфейс понравился меньше, чем у **JCommander**; второй обязывает пользователя заводить отдельных класс для аргументов, в котором можно обычные поля примитивных типов и добавлять к ним аннотации, а **commons-cli** предлагает заводить отдельные опции как объекты класса `Option`.
